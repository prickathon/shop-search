'use strict';

// A fork of babel-traverse Renamer class, optimized for renaming multiple bindings
// https://github.com/babel/babel/blob/v6.26.3/packages/babel-traverse/src/scope/lib/renamer.js

const t = require('babel-types');

const renameVisitor = {
  ReferencedIdentifier(path, states) {
    states.forEach(state => {
      if (path.node.name === state.oldName && path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {
        path.node.name = state.newName;

        return true;
      }
    });
  },
  'AssignmentExpression|Declaration'(path, states) {
    let ids = path.getOuterBindingIdentifiers();

    states.forEach(state => {
      if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {
        return;
      }

      let id = ids[state.oldName];

      if (id) {
        id.name = state.newName;

        return true;
      }
    });
  }
};

class Renamer {
  constructor(binding, oldName, newName) {
    this.newName = newName;
    this.oldName = oldName;
    this.binding = binding;
  }

  maybeConvertFromExportDeclaration(parentDeclar) {
    let exportDeclar = parentDeclar.parentPath.isExportDeclaration() && parentDeclar.parentPath;

    if (!exportDeclar) {
      return;
    }

    // build specifiers that point back to this export declaration
    let isDefault = exportDeclar.isExportDefaultDeclaration();

    if (isDefault && (parentDeclar.isFunctionDeclaration() || parentDeclar.isClassDeclaration()) && !parentDeclar.node.id) {
      // Ensure that default class and function exports have a name so they have a identifier to
      // reference from the export specifier list.
      parentDeclar.node.id = parentDeclar.scope.generateUidIdentifier('default');
    }

    let bindingIdentifiers = parentDeclar.getOuterBindingIdentifiers();
    let specifiers = [];

    for (let name in bindingIdentifiers) {
      let localName = name === this.oldName ? this.newName : name;
      let exportedName = isDefault ? 'default' : name;

      specifiers.push(t.exportSpecifier(t.identifier(localName), t.identifier(exportedName)));
    }

    if (specifiers.length) {
      let aliasDeclar = t.exportNamedDeclaration(null, specifiers);

      // hoist to the top if it's a function
      if (parentDeclar.isFunctionDeclaration()) {
        aliasDeclar._blockHoist = 3;
      }

      exportDeclar.insertAfter(aliasDeclar);
      exportDeclar.replaceWith(parentDeclar.node);
    }
  }

  prepare() {
    let path = this.binding.path;

    let parentDeclar = path.find(path => path.isDeclaration() || path.isFunctionExpression());

    if (parentDeclar) {
      this.maybeConvertFromExportDeclaration(parentDeclar);
    }

    return this;
  }

  rename() {
    let binding = this.binding,
        oldName = this.oldName,
        newName = this.newName;
    let scope = binding.scope;


    scope.removeOwnBinding(oldName);
    scope.bindings[newName] = binding;
    this.binding.identifier.name = newName;

    if (binding.type === 'hoisted') {
      // https://github.com/babel/babel/issues/2435
      // todo: hoist and convert function to a let
    }
  }
}

module.exports = (scope, names) => {
  // let renamers = Object.keys(names).map(oldName => {
  //   let binding = scope.getBinding(oldName);

  //   if (!binding) {
  //     throw new Error(`Cannot find variable ${oldName}`);
  //   }
  //   let newName = names[oldName];

  //   return new Renamer(binding, oldName, newName).prepare();
  // });

  // if (!renamers.length) {
  //   return;
  // }

  // scope.traverse(scope.block, renameVisitor, renamers);

  // renamers.forEach(renamer => renamer.rename(scope));
  for (let oldName in names) {
    let i = 0;
    let newName = names[oldName];

    let binding = scope.getBinding(oldName);
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = binding.constantViolations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        let violation = _step.value;

        let bindingIds = violation.getBindingIdentifierPaths(true, false);
        for (let name in bindingIds) {
          if (name === oldName) {
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
              for (var _iterator3 = bindingIds[name][Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                let idPath = _step3.value;

                idPath.node.name = newName;
              }
            } catch (err) {
              _didIteratorError3 = true;
              _iteratorError3 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion3 && _iterator3.return) {
                  _iterator3.return();
                }
              } finally {
                if (_didIteratorError3) {
                  throw _iteratorError3;
                }
              }
            }
          }
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = binding.referencePaths[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        let path = _step2.value;

        if (newName.endsWith('createListView')) {
          console.log(path.parent.type);
        }
        if (path.node.name === oldName && !(path.parentPath.isFunctionExpression() && path.node.id[t.NOT_LOCAL_BINDING])) {
          path.node.name = newName;
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    binding.identifier.name = newName;

    scope.bindings[newName] = binding;
    delete scope.bindings[oldName];
  }
};