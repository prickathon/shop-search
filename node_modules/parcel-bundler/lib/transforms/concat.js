'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _require = require('path');

const relative = _require.relative;

const babylon = require('babylon');
const template = require('babel-template');
const t = require('babel-types');
const traverse = require('babel-traverse').default;
const generate = require('babel-generator').default;

const EXPORTS_RE = /^\$([\d]+)\$exports$/;
const EXPORT_RE = /^\$([\d]+)\$export\$(.+)$/;

const DEFAULT_INTEROP_TEMPLATE = template('$parcel$interopDefault(MODULE)');
const THROW_TEMPLATE = template('$parcel$missingModule(MODULE)');

module.exports = packager => {
  let code = packager.contents,
      exports = packager.exports,
      addedAssets = packager.addedAssets;
  // console.log(code)

  let ast = babylon.parse(code, {
    allowReturnOutsideFunction: true
  });
  // Share $parcel$interopDefault variables between modules
  let interops = new Map();
  let assets = Array.from(addedAssets).reduce((acc, asset) => {
    acc[asset.id] = asset;

    return acc;
  }, {});

  let resolveModule = (id, name) => {
    let module = assets[id];
    return module.depAssets.get(module.dependencies.get(name));
  };

  function replaceExportNode(id, name, path) {
    let node = find(id, id => `$${id}$export$${name}`);

    if (!node) {
      // if there is no named export then lookup for a CommonJS export
      node = find(id, id => `$${id}$exports`) || t.identifier(`$${id}$exports`);

      console.trace('HIER ' + node.name + '.' + name);

      // if there is a CommonJS export return $id$exports.name
      return t.memberExpression(node, t.identifier(name));
    }

    return node;

    function find(id, symbol) {
      let computedSymbol = symbol(id);

      // if the symbol is in the scope there is not need to remap it
      if (path.scope.getProgramParent().hasBinding(computedSymbol)) {
        return t.identifier(computedSymbol);
      }

      if (exports.has(computedSymbol)) {
        return t.identifier(exports.get(computedSymbol));
      }

      // default exports are excluded from wildcard exports
      if (id in assets && name !== 'default') {
        /* recursively lookup the symbol
         * this is needed when there is deep export wildcards, like in the following:
         * - a.js
         *   > export * from './b'
         * - b.js
         *   > export * from './c'
         * - c.js in es6
         *   > export * from 'lodash'
         * - c.js in cjs
         *   > module.exports = require('lodash')
         */
        let node = null;

        assets[id].cacheData.wildcards.find(name => node = find(resolveModule(id, name).id, symbol));

        return node;
      }

      return null;
    }
  }

  console.time('concat');

  traverse(ast, {
    CallExpression(path) {
      var _path$node = path.node;
      let args = _path$node.arguments,
          callee = _path$node.callee;


      if (!t.isIdentifier(callee)) {
        return;
      }

      // each require('module') call gets replaced with $parcel$require(id, 'module')
      if (callee.name === '$parcel$require') {
        var _args = _slicedToArray(args, 2);

        let id = _args[0],
            source = _args[1];


        if (args.length !== 2 || !t.isNumericLiteral(id) || !t.isStringLiteral(source)) {
          throw new Error('invariant: invalid signature, expected : $parcel$require(number, string)');
        }

        let mod = resolveModule(id.value, source.value);

        if (!mod) {
          if (assets[id.value].dependencies.get(source.value).optional) {
            path.replaceWith(THROW_TEMPLATE({ MODULE: t.stringLiteral(source.value) }));
          } else {
            throw new Error(`Cannot find module "${source.value}" in asset ${id.value}`);
          }
        } else {
          path.replaceWith(t.identifier(`$${mod.id}$exports`));
        }
      } else if (callee.name === '$parcel$import') {
        var _args2 = _slicedToArray(args, 4);

        let id = _args2[0],
            source = _args2[1],
            name = _args2[2],
            replace = _args2[3];


        replace = path.get('arguments.3').evaluate();

        if (args.length !== 4 || !t.isNumericLiteral(id) || !t.isStringLiteral(source) || !t.isStringLiteral(name) // ||
        // !t.isBooleanLiteral(replace)
        ) {
            throw new Error('invariant: invalid signature, expected : $parcel$import(number, string, string, boolean)');
          }

        let mod = resolveModule(id.value, source.value);

        if (typeof mod === 'undefined') {
          throw new Error(`Cannot find module "${source.value}" in asset ${id.value}`);
        }

        let node = replaceExportNode(mod.id, name.value, path);
        let interop = false;

        // If the module has any CommonJS reference, it still can have export/import statements.
        if (mod.cacheData.isCommonJS) {
          if (name.value === 'default') {
            node = t.isMemberExpression(node) ? node.object : node;
            interop = true;

            let nodeName = replace.value && t.isIdentifier(node) ? node.name : null;
            let id = path.parent.id;


            if (nodeName !== null && interops.has(nodeName)) {
              let name = t.identifier(interops.get(nodeName));

              // Rename references to the variables to the cached interop name.
              path.scope.getBinding(id.name).referencePaths.forEach(reference => reference.replaceWith(t.memberExpression(name, t.identifier('d'))));
              // Remove the binding and its definition.
              path.scope.removeBinding(id.name);
              path.parentPath.remove();

              return;
            } else {
              node = DEFAULT_INTEROP_TEMPLATE({ MODULE: node });

              // Save the variable name of the interop call for further use.
              if (nodeName !== null) {
                interops.set(nodeName, id.name);
              }
            }
          }
        } else if (mod.cacheData.isES6Module && !t.isIdentifier(node) && mod.id in assets) {
          let relativePath = relative(packager.options.rootDir, mod.name);

          throw new Error(`${relativePath} does not export '${name.value}'`);
        }

        if (replace.value) {
          if (!path.parentPath.isVariableDeclarator()) {
            throw new Error('invariant: "replace" used outside of a VariableDeclarator');
          }

          let id = path.parent.id;

          let binding = path.scope.getBinding(id.name);

          if (interop) {
            path.replaceWith(node);

            binding.referencePaths.forEach(reference => reference.replaceWith(t.memberExpression(id, t.identifier('d'))));
          } else {
            path.scope.removeBinding(id.name);

            binding.path.remove();
            binding.referencePaths.forEach(reference => reference.replaceWith(node));

            if (t.isIdentifier(node)) {
              exports.set(id.name, node.name);
            }
          }
        } else {
          path.replaceWith(node);
        }
      } else if ((callee.name === '$parcel$interopDefault' || callee.name === '$parcel$exportWildcard') && !path.getData('markAsPure')) {
        // This hints Uglify and Babel that this CallExpression does not have any side-effects.
        path.addComment('leading', '#__PURE__');
        path.setData('markAsPure', true);
      } else if (callee.name === '$parcel$require$resolve') {
        var _args3 = _slicedToArray(args, 2);

        let id = _args3[0],
            source = _args3[1];


        if (args.length !== 2 || !t.isNumericLiteral(id) || !t.isStringLiteral(source)) {
          throw new Error('invariant: invalid signature, expected : $parcel$require$resolve(number, string)');
        }

        let mapped = assets[id.value];
        let dep = mapped.dependencies.get(source.value);
        let mod = mapped.depAssets.get(dep);
        let bundles = mod.id;

        if (dep.dynamic && packager.bundle.childBundles.has(mod.parentBundle)) {
          bundles = [packager.getBundleSpecifier(mod.parentBundle)];

          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = mod.parentBundle.siblingBundles[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              let child = _step.value;

              if (!child.isEmpty) {
                bundles.push(packager.getBundleSpecifier(child));
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          bundles.push(mod.id);
        }

        path.replaceWith(t.valueToNode(bundles));
      }
    },
    MemberExpression(path) {
      if (!path.isReferenced()) {
        return;
      }

      var _path$node2 = path.node;
      let object = _path$node2.object,
          property = _path$node2.property;

      if (!t.isIdentifier(object) || !t.isIdentifier(property)) {
        return;
      }

      let match = object.name.match(EXPORTS_RE);

      // If it's a $id$exports.name expression.
      if (match) {
        let exportName = '$' + match[1] + '$export$' + property.name;

        // Check if $id$export$name exists and if so, replace the node by it.
        if (path.scope.hasBinding(exportName)) {
          path.replaceWith(t.identifier(exportName));
        }
      }
    },
    ReferencedIdentifier(path) {
      let name = path.node.name;


      if (typeof name !== 'string') {
        return;
      }

      // If it's a renamed export replace it with its alias.
      if (exports.has(name)) {
        path.replaceWith(t.identifier(exports.get(path.node.name)));
      }

      let match = name.match(EXPORT_RE);

      // If it's an undefined $id$export$name identifier.
      if (match && !path.scope.hasBinding(name)) {
        let id = Number(match[1]);
        let exportName = match[2];

        // Check if there is a wildcard or an alias (Identifier), else use CommonJS (MemberExpression).
        path.replaceWith(replaceExportNode(id, exportName, path));

        return;
      }

      match = name.match(EXPORTS_RE);

      // If it's an undefined $id$exports identifier.
      if (match && !path.scope.hasBinding(name)) {
        let id = Number(match[1]);

        // If the id is in the bundle it may just be empty, replace with {}.
        if (id in assets) {
          path.replaceWith(t.objectExpression([]));
        }
        // Else it should be required from another bundle, replace with require(id).
        else {
            path.replaceWith(t.callExpression(t.identifier('require'), [t.numericLiteral(id)]));
          }

        return;
      }
    },
    Program: {
      // A small optimization to remove unused CommonJS exports as sometimes Uglify doesn't remove them.
      exit(path) {
        // Recrawl to get all bindings.
        path.scope.crawl();

        // Object.keys(path.scope.bindings).forEach(name => {
        //   let binding = getUnusedBinding(path, name);

        //   // If it is not safe to remove the binding don't touch it.
        //   if (!binding) {
        //     return;
        //   }

        //   // Remove the binding and all references to it.
        //   binding.path.remove();
        //   binding.referencePaths
        //     .concat(binding.constantViolations)
        //     .forEach(path => {
        //       if (path.parentPath.isMemberExpression()) {
        //         if (!path.parentPath.parentPath.removed) {
        //           path.parentPath.parentPath.remove();
        //         }
        //       } else if (path.isAssignmentExpression()) {
        //         path.remove();
        //       }
        //     });

        //   path.scope.removeBinding(name);
        // });
        return;

        let Charset = require('babel-plugin-minify-mangle-names/lib/charset');
        let charset = new Charset(false);
        charset.sort();

        let rename = require('../visitors/renamer');
        let bindings = {};
        let newNames = new Set();
        let size = 0;

        let binds = Object.keys(path.scope.bindings).sort((a, b) => path.scope.bindings[b].referencePaths.length - path.scope.bindings[a].referencePaths.length);

        let scope = path.scope.getProgramParent();

        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = binds[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            let oldName = _step2.value;

            let i = 0;
            let newName;

            do {
              newName = charset.getIdentifier(i++);
            } while (!t.isValidIdentifier(newName) || newNames.has(newName) || !canRename(scope, path.scope.bindings[oldName], newName));
            bindings[oldName] = newName;
            newNames.add(newName);

            let binding = path.scope.getBinding(oldName);
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
              for (var _iterator3 = binding.constantViolations[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                let violation = _step3.value;

                let bindingIds = violation.getBindingIdentifierPaths(true, false);
                for (let name in bindingIds) {
                  if (name === oldName) {
                    var _iteratorNormalCompletion5 = true;
                    var _didIteratorError5 = false;
                    var _iteratorError5 = undefined;

                    try {
                      for (var _iterator5 = bindingIds[name][Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                        let idPath = _step5.value;

                        idPath.node.name = newName;
                      }
                    } catch (err) {
                      _didIteratorError5 = true;
                      _iteratorError5 = err;
                    } finally {
                      try {
                        if (!_iteratorNormalCompletion5 && _iterator5.return) {
                          _iterator5.return();
                        }
                      } finally {
                        if (_didIteratorError5) {
                          throw _iteratorError5;
                        }
                      }
                    }
                  }
                }
              }
            } catch (err) {
              _didIteratorError3 = true;
              _iteratorError3 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion3 && _iterator3.return) {
                  _iterator3.return();
                }
              } finally {
                if (_didIteratorError3) {
                  throw _iteratorError3;
                }
              }
            }

            var _iteratorNormalCompletion4 = true;
            var _didIteratorError4 = false;
            var _iteratorError4 = undefined;

            try {
              for (var _iterator4 = binding.referencePaths[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                let path = _step4.value;

                if (path.node.name === oldName) {
                  path.node.name = newName;
                }
              }
            } catch (err) {
              _didIteratorError4 = true;
              _iteratorError4 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion4 && _iterator4.return) {
                  _iterator4.return();
                }
              } finally {
                if (_didIteratorError4) {
                  throw _iteratorError4;
                }
              }
            }

            binding.identifier.name = newName;

            path.scope.bindings[newName] = binding;
            delete path.scope.bindings[oldName];
          }

          // console.log(bindings)
          // rename(path.scope, bindings);
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }
    }
  });

  function canRename(scope, binding, newName) {
    for (let i = 0; i < binding.referencePaths.length; i++) {
      const ref = binding.referencePaths[i];
      if (ref.scope.hasBinding(newName) || ref.scope.hasReference(newName)) {
        return false;
      }
    }

    return true;
  }

  console.timeEnd('concat');

  console.time('minify');
  // let tmp = require('babel-core').transformFromAst(ast, code, {
  //   babelrc: false,
  //   code: false,
  //   filename: 'jhi',
  //   plugins: [/*[require('babel-plugin-minify-mangle-names'), {topLevel: true}], */require('babel-plugin-minify-dead-code-elimination')]
  // });

  // ast = tmp.ast;
  console.timeEnd('minify');

  let opts = {
    sourceMaps: packager.options.sourceMaps,
    sourceFileName: packager.bundle.name,
    minified: true,
    comments: false
  };

  console.time('generate');
  let res = generate(ast, opts, code);
  console.timeEnd('generate');
  console.log('\n\n');
  return res;
};

// Check if a binding is safe to remove and returns it if it is.
function getUnusedBinding(path, name) {
  let binding = path.scope.getBinding(name);

  if (binding.referencePaths.length === 0 && (binding.path.isPureish() || name.startsWith('$parcel'))) {
    return binding;
  }

  if (!EXPORTS_RE.test(name)) {
    return null;
  }

  // Is there any references which aren't simple assignments?
  let bailout = binding.referencePaths.some(path => !isExportAssignment(path) && !isUnusedWildcard(path));

  if (bailout) {
    return null;
  } else {
    return binding;
  }

  function isExportAssignment(path) {
    return (
      // match "path.any = any;"
      path.parentPath.isMemberExpression() && path.parentPath.parentPath.isAssignmentExpression() && path.parentPath.parentPath.node.left === path.parentPath.node
    );
  }

  function isUnusedWildcard(path) {
    let parent = path.parent,
        parentPath = path.parentPath;


    return (
      // match "var $id$exports = $parcel$exportWildcard(any, path);"
      t.isCallExpression(parent) && t.isIdentifier(parent.callee, { name: '$parcel$exportWildcard' }) && parent.arguments[1] === path.node && parentPath.parentPath.isVariableDeclarator() &&
      // check if the $id$exports variable is used
      getUnusedBinding(path, parentPath.parent.id.name) !== null
    );
  }
}